**WHAT IS A DECORATOR?**
 a function that modifies another function

 *Why Use Decorators?*
Adding Functionality: Decorators let you add new features, like logging, timing, or checking permissions, without changing the original function's code.

Reusability: You can use the same decorator on multiple functions to give them similar behavior, like logging messages or enforcing rules.


```py
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Before calling the function!")
        result = func(*args, **kwargs)
        print("After calling the function!")
        return result
    return wrapper

@my_decorator
def greet(name):
    return f"Hello, {name}!"

# When you call greet
message = greet("Alice")
print(message)

#This is the output 
Before calling the function!
After calling the function!
Hello, Alice!

```

 @PROPERTY
 The property decorator in Python is used to define a method in a class that can be accessed like an attribute. It allows you to customize the behavior of getting, setting, and deleting a value in a class while still providing a clean interface.
 treat a methods as an - control access to a private attribute
 #when ever you see _Radious, just know that its private
 Good for creating readOnly

 @STATIC METHOD
  allows you to define a method that belongs to a class but does not depend on instance-specific data.. No Self or cls

 @CLASS METHOD
It can modify class state that applies across all instances of the class
 Can only access things that are defined on a class not on an insance



@FUNCTOOLS.CACHE
```py
def fibonacci (n):
    if n<2:
        return n
    return fibonacci(n-1) +fibonacci(n-2)   

 fibonacci(40)
 ```

   we will modify this and add our custom cache:

```py
def fibonacci (n):
    if n in cache:
        return cache(n)

    if n==0:
        return 0
    elif n==1:    
      return 1
      
      cache[n]=fibonacci(n-1, cache) +fibonacci(n-2, cache)  
      return cache[n] 

 print(fibonacci(40))

 #we can do this in python without having to modify the function like

 @functools.cache
 def fibonacci (n):
    if n<2:
        return n
    return fibonacci(n-1) +fibonacci(n-2)   

 fibonacci(40)
 ```

 @DATACLASS DECORATOR
 A convenient way to define classes that are primarily used to store data. It automatically generates special methods for you, such as __init__, __repr__, __eq__, and more, based on the class attributes you define. 
 to make things eisierThis saves you from writing boilerplate code and makes your code cleaner and easier to read.

 ```py
 from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int
    address: str

# Creating an instance of Person
person1 = Person(name="Alice", age=30, address="123 Main St")

# Accessing attributes
print(person1.name)   # Output: Alice
print(person1.age)    # Output: 30
print(person1.address)  # Output: 123 Main St

# Using the autogenerated __repr__ method
print(person1)  # Output: Person(name='Alice', age=30, address='123 Main St')
```